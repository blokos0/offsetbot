--[[
WARNING!!!

This file will spoil every level!
I recommend you try the pack first.








Please?












Okay, you asked for it.]]

hintdata = {
  ["2level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "What property can destroy @text@?",
      [2] = "Is there way to refer to the @flag@?",
      [3] = "You can't remove the @flag@, but can you get past it?",
    },
    [2] = {
      ["name"] = "transform",
      [1] = "This is actually a red herring. There's no way to transform this\n@level@ because the @baba@ is in the way.",
      [2] = "If you could, you could transform this into something useful.",
    },
  },
  ["3level"] = {
    [1] = {
      ["name"] = "Access bottom right",
      [1] = "Why is that @is@ placed between those two @level@s?",
      [2] = "What object is in both @level@s 1 and 2?",
    },
    [2] = {
      ["name"] = "win",
      [1] = "Which @level@ can be turned into @win@ text?",
      [2] = "How could you remain @you@ and after transforming the first @level@?",
      [3] = "What object is in both @level@s 2 and 3?",
    },
  },
  ["5level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "You can't @win@ because the @level@ gets transformed. What phrase\nwould prevent that?",
      [2] = "You need to make @level@ @is@ @not@ @text@, but how can you refer to @text@?",
      [3] = "There isn't enough @text@ right now. Find a way to make some more.",
      [4] = "@baba@ @is@ @all@ turns @baba@ into @baba@. Pointless?",
      [5] = "@baba@ @write@ @not@ @all@ simply prevents @baba@ @write@ @all@.\nIs there a way around this?",
    },
    [2] = {
      ["name"] = "transform 1",
      [1] = "You can't push any @text@ into the corridor, but can you still\nget @text@ there nonetheless?",
    },
    [3] = {
      ["name"] = "transform 2",
      [1] = "...You're trying to @win@, right?",
    },
  },
  ["6level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "What can you use @near@ for?",
      [2] = "Can you override @baba@ @is@ @baba@?",
      [3] = "In @level@ 1, how did you refer to the @flag@?",
    },
    [2] = {
      ["name"] = "transform 1",
      [1] = "What object was in the previous @level@?",
      [2] = "You can make @baba@ @push@, but it's stuck. Is there a way\nto make a @baba@ you can access?",
      [3] = "You need @baba@ @text@ to transform this @level@.",
      [4] = "Remember that @baba@ @is@ @not@ @baba@ overrides @baba@ @is@ @baba@.",
    },
    [3] = {
      ["name"] = "transform 2",
      [1] = "What object was in @level@ 3?",
      [2] = "You'll need at least one extra @it@.",
      [3] = "Maybe even two extra @it@s.",
      [4] = "Maybe something similar to the first transform would work.",
    },
  },
  ["7level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "You need more @text@. There's a verb you can spell that might help.",
      [2] = "There's only 1 @is@. Can you still transform an object into multiple things?",
      [3] = "You can't write @not@ @fofo@ @is@ @you@, but there's\nstill a way to write @it@ @is@ @you@.",
      [4] = "It's neat how replacing the @i@ in @it@ with @no@ makes @not@.",
      [5] = "You can't make @it@ and @fofo@ both @you@... at the same time.",
    },
    [2] = {
      ["name"] = "transform 1",
      [1] = "You don't need the @leaf@.",
      [2] = "Pushing the @you@ breaks @fofo@ @is@ @you@.\nCan you still become @you@ again?",
      [3] = "Perhaps some rule would let you move the @level@ @text@.",
    },
    [3] = {
      ["name"] = "transform 2",
      [1] = "That small opening above the @it@ @text@ is there for a reason.",
      [2] = "Try something like the first transform.",
    },
  },
  ["1level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "This should be obvious. Just touch the @flag@.",
      [2] = "If it weren't for the @baba@ on the map, you would be stuck here\nand have to delete your save data.",
    },
  },
  ["10level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "What does @not@ @delete@ do?",
      [2] = "There's only one @rock@ above. If only there was a way to\nget rid of one of the liquids.",
      [3] = "The bottom @rock@ is in the way.",
    },
  },
  ["11level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "There's a way to refer to the @cliff@.",
      [2] = "This requires some out-of-box thinking.",
      [3] = "@text@ can be pushed onto non-solid objects.",
    },
  },
  ["12level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "You need to get rid of the @crystal@. Is there a way to do that?",
      [2] = "How can you avoid making @bat@ @is@ @rock@?",
      [3] = "What can you make @win@?",
    },
  },
  ["13level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "Check out @level@ 5.",
      [2] = "Is there a way to avoid sinking all of that @text@?",
      [3] = "Why is the area next to @flag@ @is@ @win@ open?",
      [4] = "If only there was a way to keep the @pillar@ without\nlosing all of the @bog@.",
      [5] = "How do you suppose @near@ interacts with @delete@?",
    },
  },
  ["14level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "Check out @level@ 4.",
    },
  },
  ["15level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "You'll need to bring stuff back to get\nthrough the @door@s.",
      [2] = "Prison tactics will help restore the rock-like wall.",
      [3] = "What @level@ had @track@?",
      [4] = "You need to get rid of one @pillar@ without getting rid of the other.",
    },
  },
  ["8level"] = {
    [1] = {
      ["name"] = "win",
      [1] = "They're in your way. Get rid of them.",
    },
    [2] = {
      ["name"] = "???",
      [1] = "Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them.\nGet rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them. Get rid of them.",
    },
  },
}

-- Adds button to menu
hintnum = 0
hintpage = 0
local old_pause = menufuncs.pause.enter
menufuncs.pause.enter = function(...)
  old_pause(...)
  createbutton("hint",50,screenh-20,2,4,1,"Hints","pause",3,2,menufuncs.pause.button)
end

buttonclick_list["hint"] = function(unitid)
  submenu("hint")
end

-- The actual hint pages
menufuncs.hint = {
  button = "Hints",
  escbutton = "hint_close",
  enter = function(parent,name,buttonid)
    local dynamic_structure = {}
    local x = screenw * 0.5
    local y = f_tilesize * 2
    local levelhints = hintdata[generaldata.strings[CURRLEVEL]]
    if levelhints ~= nil then
      writetext("What are you trying to do?",0,x,y,name,true,2)
      for i,data in ipairs(levelhints) do
        y = y + f_tilesize
        createbutton("goal"..i,x,y,2,12,1,data.name,name,1,3,buttonid)
        table.insert(dynamic_structure,{{"goal"..i}})
        buttonclick_list["goal"..i] = function(unitid)
          hintnum = i
          hintpage = 1
          submenu("viewhint")
        end
      end
      y = y + f_tilesize
    else
      writetext("No hints available for this level.",0,x,y,name,true,2)
    end
    y = y + f_tilesize
    createbutton("hint_close",x,y,2,12,1,langtext("editor_menu_close"),name,1,3,buttonid)
    table.insert(dynamic_structure,{{"hint_close"}})
    buildmenustructure(dynamic_structure)
  end,
  leave = function(parent,name,buttonid)
    MF_letterclear(name)
  end,
}
menufuncs.viewhint = {
  button = "HintView",
  escbutton = "hint_close",
  enter = function(parent,name,buttonid)
    local dynamic_structure = {}
    local x = screenw * 0.5
    local y = f_tilesize * 2
    local thishint = hintdata[generaldata.strings[CURRLEVEL]][hintnum]
    if thishint ~= nil then
      local totalpages = 1
      while thishint[totalpages] ~= nil do
        totalpages = totalpages + 1
      end
      totalpages = totalpages - 1

      writetext(thishint.name,0,x,y,name,true,2)
      y = y + f_tilesize
      local text = thishint[hintpage]

      local length = string.len(text)
      local i = 1
      while (i <= length) do
    		local letter = string.sub(text, i, i)

    		if (letter == "@") then
    			local sublength = 0
    			local command = ""

    			for j=i,length do
    				local subletter = ""

    				if (j < length) then
    					subletter = string.sub(text, j+1, j+1)
    				end

    				sublength = sublength + 1

    				if (subletter == "@") or (j == length) then
    					command = string.sub(text, i+1, j)
              local displayname = word_names[command] or command
              local object = colourstring(command,displayname)
              local referdead = MF_read("world","deadunits",command)
              if tonumber(referdead) == 1 then
                object = "$2,2NOT FOUND$0,3"
              end

    					text = string.gsub(text, "@" .. command .. "@", object)

              length = string.len(text)
    					i = i + string.len(object)
    					break
    				end
    			end
    		end

        if (letter == "\n") then
          local subtext = string.sub(text,1,i-1)
          text = string.sub(text,i+1)
          writetext(subtext,0,x,y,name,true,2)
          y = y + f_tilesize
          length = string.len(text)
          i = 0
    		end

    		i = i + 1
    	end

      writetext(text,0,x,y,name,true,2)
      y = f_tilesize * 6
      writetext("Hint "..hintpage.." / "..totalpages,0,x,y,name,true,2)
      y = y + f_tilesize
      createbutton("hint_back",x-100,y,2,6,1,"<",name,1,3,buttonid,(hintpage <= 1))
      createbutton("hint_forward",x+100,y,2,6,1,">",name,1,3,buttonid,(hintpage >= totalpages))
      table.insert(dynamic_structure,{{"hint_back"},{"hint_forward"}})
      y = y + f_tilesize
    else
      writetext("No data for this section.",0,x,y,name,true,2)
    end
    y = y + f_tilesize
    createbutton("hint_close",x,y,2,12,1,langtext("editor_menu_close"),name,1,3,buttonid)
    table.insert(dynamic_structure,{{"hint_close"}})
    buildmenustructure(dynamic_structure)
  end,
  leave = function(parent,name,buttonid)
    MF_letterclear(name)
  end,
}
buttonclick_list["hint_back"] = function(unitid)
  hintpage = hintpage - 1
  closemenu()
  submenu("viewhint")
end
buttonclick_list["hint_forward"] = function(unitid)
  hintpage = hintpage + 1
  closemenu()
  submenu("viewhint")
end
buttonclick_list["hint_close"] = function(unitid)
  closemenu()
end

-- Returns a string with colour from a string without colour.
function colourstring(text_,display_,custom)
  local text = text_ or ""
  local display = display_ or text
  local result = ""
  if string.sub(text,1,4) == "not " and custom == nil then
    local n1,n2 = getpalcolour("text_not","active")
    if n1 ~= 0 or n2 ~= 3 then
      result = "$"..n1..","..n2.."not "
    else
      result = "not "
    end
    text = string.sub(text,5)
    display = string.sub(display,5)
  end
  local c1,c2 = getpalcolour("text_"..text,"active",true)
  while string.sub(text,1,5) == "text_" and custom == nil and c1 == nil do
    local n1,n2 = getpalcolour("text_text_","active")
    if n1 ~= 0 or n2 ~= 3 or result ~= nil then
      result = result.."$"..n1..","..n2.."text_"
    else
      result = "text_"
    end
    text = string.sub(text,6)
    display = string.sub(display,6)
    c1,c2 = getpalcolour("text_"..text,"active",true)
  end
  if c1 == nil then
    c1,c2 = 0,3
  end
  local insert = custom or display
	-- metatext display
	if true then
		local textcount = 0
		insert,textcount = string.gsub(insert,"text_","")
		if insert == "" then
			insert = "text_"
			textcount = textcount - 1
		end
		if textcount > 0 then
			insert = insert .. "("..textcount..")"
		end
	end
  if (c1 ~= 0 or c2 ~= 3) then
    result = result .. "$"..c1..","..c2..insert.."$0,3"
  elseif result ~= "" then
    result = result .. "$0,3" .. insert
  else
    result = insert
  end
  return result
end

-- Returns the colour of the name entered from the object palette.
function getpalcolour(object,value_,checkexist)
  local name = ""
  if unitreference[object] ~= nil then
    name = unitreference[object]
  elseif objectpalette[object] ~= nil then
    name = objectpalette[object]
  end
  if #name > 0 then
    local unitinfo = tileslist[name]

  	local defaultcolour = colours.default

  	local value = value_ or "colour"

  	if (objectcolours[name] ~= nil) then
  		local c = objectcolours[name]

  		if (c[value] ~= nil) then
  			local cc = c[value]
  			return cc[1],cc[2]
  		elseif (value == "colour") or (unitinfo == nil) or (unitinfo[value] == nil) then
  			if (c.colour ~= nil) then
  				local cc = c.colour
  				return cc[1],cc[2]
  			end
  		end
  	end

  	if (unitinfo == nil) then
  		return defaultcolour[1],defaultcolour[2]
  	else
  		if (unitinfo[value] == nil) then
  			if (unitinfo.colour == nil) then
  				return defaultcolour[1],defaultcolour[2]
  			else
  				local colour = unitinfo.colour
  				return colour[1],colour[2]
  			end
  		else
  			local colour = unitinfo[value]
  			return colour[1],colour[2]
  		end
  	end

  	return defaultcolour[1],defaultcolour[2]
  end
  if checkexist then
    return nil
  end
  return 0,3
end


-- Haha, I lied. This file has more than just the hints.
spookmode = false
local alldead = MF_read("world","deadunits","all")
if tonumber(alldead) == 1 then
  MF_setfile("level","the truth.txt")
  MF_store("level","NOTICE","There's no way to restore this levelpack."
  .."\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  .."Or is there?\n"
  .."Data/Worlds/not_a_pack/world_data.txt\n"
  .."Delete all of deadunits ",")")
  if editor.values[INEDITOR] ~= 1 then
    map = TileMap.new(10) -- crash game
  else
    error(INVALID_VALUE) -- the previous doesn't actually crash in the editor, so do this instead
    -- unlike the other, this instantly crashes the game, so the next error does not display
  end
  error("Data/load.lua:2: bad argument #1 to 'new' (number expected, got nil)\nCheck crash.txt for more info.",999)
  return
end

-- Adds the NOT property
table.insert(editor_objlist_order, "text_delete")
word_names["delete"] = "$2,2Not"
editor_objlist["text_delete"] = {
  name = "text_delete",
  unittype = "text",
  sprite_in_root = false,
  sprite = "text_not_prop",
  tags = {"text","text_quality"},
  tiling = -1,
  type = 2,
  layer = 20,
  colour = {2, 1},
  colour_active = {2, 2},
}

formatobjlist()

-- implementation
function dodelete()
  local restart = false
  if featureindex["delete"] ~= nil then
    local alreadydone = {}
    for a,rule in ipairs(featureindex["delete"]) do
      local target = rule[1][1]
      local conds = rule[2]

      local newdeadstatus = conds_to_string(conds)

      local dead = get_dead_status(target)
      local minusdead,found = string.gsub(dead,newdeadstatus,"")

      if target ~= "$2,2NOT FOUND$0,3" and string.sub(target,1,4) ~= "not " and (conds[1] == nil or conds[1][1] ~= "never") and alreadydone[target] == nil and dead ~= "yes" then
        alreadydone[target] = 1
        if newdeadstatus ~= "yes" then
          MF_store("world","deadunits",target,minusdead..newdeadstatus)
        else
          MF_store("world","deadunits",target,1)
        end
        restart = true
        if target == "all" then
          -- change world data
          MF_store("world","general","name","")
          MF_store("world","general","author","")
          MF_setfile("level","Data/Worlds/"..generaldata.strings[WORLD].."/icon.png")
          MF_store("level","oops","issue","aaa") -- just corrupt the image so it doesn't load properly

          MF_setfile("level","temp/AD5D-XBA3.png") -- nobody's gonna look here, right?
          MF_store("level","truth","killed",1)
          map = TileMap.new(10) -- crash game
          -- the actual crash is a bit later, so stuff saves
          return
        end
      end
    end
  end
  if featureindex["not delete"] ~= nil then
    local alreadydone = {}
    for a,rule in ipairs(featureindex["not delete"]) do
      local target = rule[1][1]
      local conds = rule[2]

      local noninvertstatus = conds_to_string(conds)
      local newdeadstatus = conds_to_string(conds,true)

      local dead = get_dead_status(target)
      local minusdead,found = string.gsub(dead,noninvertstatus,"")
      if minusdead == "yes" or newdeadstatus == "" then
        minusdead = ""
      end

      if target ~= "$2,2NOT FOUND$0,3" and string.sub(target,1,4) ~= "not " and (conds[1] == nil or conds[1][1] ~= "never") and alreadydone[target] == nil and dead ~= "" then
        alreadydone[target] = 1
        MF_store("world","deadunits",target,minusdead..newdeadstatus)
        restart = true
      end
    end
  end

  if restart then
    MF_restart(true)
  end
end
table.insert(mod_hook_functions["turn_end"],dodelete)

-- also implementation
function rekill()
  local delthese = {}
  local killed = false
  local doerror = false
  for i,unit in ipairs(units) do
    local name = getname(unit)

    local dead = get_dead_status(name)
    local referdead = get_dead_status(unit.strings[NAME])

    local dokill = false
    local dotextglitch = false

    if dead == "yes" then
      dokill = true
    elseif dead ~= "" then
      local conds = string_to_conds(dead)
      if conds ~= nil then
        dokill = testcond(conds,unit.fixed) -- FIX THIS
      else
        dokill = true
      end
    elseif referdead == "yes" then
      dotextglitch = true
    end

    if dokill then
      if MF_keydown("v") and editor.values[INEDITOR] == 1 then
        MF_store("world","deadunits",name,0)
      else
        if dead == "yes" then
          objectlist[name] = nil
        end
        table.insert(delthese, unit.fixed)
        killed = true
        local firsttime = MF_read("world","deadunits","firsttime")
        if name == "baba" then
          if generaldata.strings[CURRLEVEL] == "1level" and tonumber(firsttime) ~= 1 then
            doerror = true
          elseif generaldata.strings[CURRLEVEL] == "2level" and tonumber(firsttime) ~= 1 then
            MF_store("world","deadunits","firsttime",1)
          end
        end
      end
    elseif dotextglitch then
      if MF_keydown("v") and editor.values[INEDITOR] == 1 then
        MF_store("world","deadunits",unit.strings[NAME],0)
      else
        objectlist[unit.strings[NAME]] = nil
        MF_changesprite(unit.fixed, "text_glitch", false)
        killed = true
      end
    end
  end
  if MF_keydown("v") and editor.values[INEDITOR] == 1 then
    MF_store("world","deadunits","firsttime",0)
  end

  handledels(delthese,false)
  undobuffer = {}
  updatecode = 1
  code(true)
  if killed then
    spookmode = true
    if doerror then
      error("Data/syntax.lua:13: attempt to index a nil value (local 'unit')"
      .. "\nPlease report this to the developers."
      .. "\nPlease report this"
      .. "\nPlease"
      .. "\n\n\n\n\ndelete this save\n\n\n\n",999)
    end
  else
    spookmode = false
  end
end
table.insert(mod_hook_functions["level_start"],rekill)

table.insert(mod_hook_functions["always"], function()
  if spookmode and generaldata2.strings[MUSIC] ~= "erased" then
    generaldata2.strings[MUSIC] = "erased"
    generaldata2.strings[OLDMUSIC] = "erased"
  end
end)

-- modify rules that contain dead units
local old_addoption = addoption
function addoption(option,conds_,ids,visible,notrule,tags_)
  local target = option[1]
  local effect = option[3]
  if effect == "delete" or effect == "not delete" then
    return old_addoption(option,conds_,ids,visible,notrule,tags_)
  elseif string.sub(target,1,4) == "not " then
    target = string.sub(target,5)
  end
  if string.sub(effect,1,4) == "not " then
    effect = string.sub(effect,5)
  end

  local dead  = get_dead_status(target)
  local dead2 = get_dead_status(effect)
  for a,cond in ipairs(conds_) do
    for b,param in ipairs(cond[2]) do
      if string.sub(param,1,4) == "not " then
        param = string.sub(param,5)
      end

      local paramdead = get_dead_status(param)
      if paramdead == "yes" then
        conds_[a][2][b] = "$2,2NOT FOUND$0,3"
      end
    end
  end
  if dead == "yes" then
    option[1] = "$2,2NOT FOUND$0,3"
  end
  if dead2 == "yes" then
    option[3] = "$2,2NOT FOUND$0,3"
  end
  return old_addoption(option,conds_,ids,visible,notrule,tags_)
end

function get_dead_status(object)
  local dead = MF_read("world","deadunits",object)
  if tonumber(dead) == 1 then
    return "yes"
  elseif tonumber(dead) == 0 or dead == "" then
    return ""
  end
  return dead
end

-- convert conditions into a string for storage
function conds_to_string(conds_,invert)
  local conds = conds_ or {}
  if invert then
    conds = invertconds(conds_)
  end
  local string = ""
  for a,cond in ipairs(conds) do
    if cond[1] == "never" then
      return ""
    end
    string = cond[1] .. "\t"
    for b,param in ipairs(cond[2]) do
      string = string .. param .. "\t"
    end
    string = string .. "\n"
  end
  if string == "" then
    return "yes"
  end
  return string
end

-- convert string into conditions
function string_to_conds(string)
  local conds = {}
  if string == "" then
    return nil
  end
  local currcond = ""
  local currparam = ""
  local params = {}
  local doingparam = false
  for i=1,string.len(string) do
    local letter = string.sub(string, i, i)
    if doingparam then
      if letter == "\t" then
        table.insert(params,currparam)
        currparam = ""
      elseif letter == "\n" then
        if currcond ~= "" then
          table.insert(conds,{currcond,params})
        end
        currcond = ""
        currparam = ""
        params = {}
      else
        currparam = currparam .. letter
      end
    else
      if letter == "\t" then
        doingparam = true
      else
        currcond = currcond .. letter
      end
    end
  end
  if currparam ~= "" then
    table.insert(params,currparam)
    currparam = ""
  end
  if currcond ~= "" then
    table.insert(conds,{currcond,params})
    currcond = ""
  end
  return conds
end

-- Hardcoded level tree (two entries lol).
hardcodetree = {
  ["3level"] = {"3level"}, --Not The Map
	["8level"] = {"3level","8level"}, --The End -> Not The Map
}
table.insert(mod_hook_functions["level_start"],
  function()
    local name = generaldata.strings[CURRLEVEL]
    if hardcodetree[name] ~= nil then
      leveltree = {}
      for i,v in ipairs(hardcodetree[name]) do
        table.insert(leveltree,v)
      end
      leveltree_id = {}
      for i,v in ipairs(leveltree) do
        local insert = getlevelid(nil,nil,v)
        table.insert(leveltree_id,insert)
      end
    end
  end
)

-- truth stuff (has to be at the end so the rest of the file loads)
MF_setfile("level","temp/AD5D-XBA3.png") -- some obscure spot
local truth = MF_read("level","truth","killed")
MF_setfile("level","Data/Worlds/" .. generaldata.strings[WORLD] .. "/" .. generaldata.strings[CURRLEVEL] .. ".ld")
if tonumber(truth) == 1 then
  local currslot = generaldata2.values[SAVESLOT] -- literally just the save slot name lol
  local slotname = MF_read("settings","slotnames",tostring(currslot))
  if (#slotname == 0) then
    error("Of course you came back.",999) -- in case there is no name
    return
  end
  error("Of course you came back, "..slotname..".",999)
end
